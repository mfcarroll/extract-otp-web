import { encode } from "thirty-two";
import { MigrationOtpParameter } from "../types";
import { getOtpParametersFromUrl } from "./otpUrlParser";
import { addUploadLog } from "../ui/notifications";
import { getState, setState } from "../state/store";
import { logger } from "./logger";

/**
 * Creates a unique and consistent key for an OTP parameter.
 * This key is used to reliably identify and prevent duplicate entries.
 * It's generated by combining the issuer, name, type, and the Base32-encoded secret.
 * @param otp The OTP parameter to generate a key for.
 * @returns A unique string identifier for the OTP.
 */
export function getOtpUniqueKey(otp: MigrationOtpParameter): string {
  const secretText = encode(otp.secret).toString();
  return `${otp.issuer}:${otp.name}:${otp.type}:${secretText}`;
}

/**
 * Filters a list of OTP parameters against a set of existing keys,
 * logs the outcome, and returns the new unique parameters.
 * @param otpParameters The list of OTP parameters to process.
 * @param existingKeys A Set of unique keys for existing OTPs. This set will be mutated.
 * @param sourceName A descriptive name for the source (e.g., a filename).
 * @returns An object containing the new OTPs and the number of duplicates found.
 */
export function filterAndLogOtps(
  otpParameters: MigrationOtpParameter[],
  existingKeys: Set<string>,
  sourceName: string
): { newOtps: MigrationOtpParameter[]; duplicatesFound: number } {
  const newOtps: MigrationOtpParameter[] = [];
  let duplicatesFound = 0;

  for (const otp of otpParameters) {
    const key = getOtpUniqueKey(otp);
    if (existingKeys.has(key)) {
      duplicatesFound++;
    } else {
      newOtps.push(otp);
      existingKeys.add(key); // Add to set to handle duplicates within the same batch
    }
  }

  if (newOtps.length > 0) {
    const plural = newOtps.length > 1 ? "s" : "";
    addUploadLog(
      sourceName,
      "success",
      `${newOtps.length} secret${plural} extracted.`
    );
  }

  if (duplicatesFound > 0) {
    const plural = duplicatesFound > 1 ? "s" : "";
    addUploadLog(
      sourceName,
      "warning",
      `${duplicatesFound} duplicate secret${plural} skipped.`
    );
  }

  return { newOtps, duplicatesFound };
}

/**
 * Centralized function to process a decoded QR code string from a single source (like a camera scan).
 * It handles parsing, duplicate checking, logging, and state updates.
 * @param qrCodeData The raw string data from a QR code.
 * @param sourceName A descriptive name for the source (e.g., "Camera Scan").
 */
export async function handleDecodedQrString(
  qrCodeData: string,
  sourceName: string
): Promise<void> {
  try {
    const otpParameters = await getOtpParametersFromUrl(qrCodeData);

    if (!otpParameters || otpParameters.length === 0) {
      addUploadLog(sourceName, "info", "No OTP secrets found in QR code.");
      return;
    }

    const existingKeys = new Set(getState().otps.map(getOtpUniqueKey));
    const { newOtps } = filterAndLogOtps(
      otpParameters,
      existingKeys,
      sourceName
    );

    if (newOtps.length > 0) {
      setState((currentState) => ({
        otps: [...currentState.otps, ...newOtps],
      }));
    }
  } catch (error: any) {
    const message =
      (error instanceof Error ? error.message : String(error)) ||
      "An unknown error occurred.";
    logger.error(`Error processing QR data from ${sourceName}:`, error);
    addUploadLog(sourceName, "error", message);
  }
}
